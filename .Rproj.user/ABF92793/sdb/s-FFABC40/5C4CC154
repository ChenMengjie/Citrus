{
    "contents" : "#' This is function to do factor analysis.\n#' @param Expression: A $n \\times q$ matrix for genes.\n#' @param Spikein: A $n \\times p$ matrix for spikeins.\n#' @param k1: The number of technical factors.\n#' @param k2: The number of structured biological factors.\n#' @param iter: The number of iterations for the EM algorithm. The default is 500.\n#' @param alpha, kappa, diagH, g, h1, h2, c, d: These are hyperparameters if using the IBP prior.\n#' @param limit: the maximal number of factors if using the IBP prior. \n#' @param method: The method used to infer the latent factors. The default is EM algorithm.\n#' Other choices include EMSparse algorithm: penalty on sparsity of the factor matrix is specified. \n#' EMSparseTraining algorithm: penalty on sparsity is learned from training samples.\n#' EMparseNfold algorithm: penalty on sparsity is learned from N fold cross-validation.\n#' IBP algorithm: the sparse factor matrix modeled by an IBP prior.\n#' PCA algorithm: The initializer for the EM algorithm. The latent factors are estimated from a SVD.\n#' @param penalty: A sequence of penality will be tested in training or cross-validation.    \n#' @param tol: Tolerance for the convergence.\n#' @param givenpenalty: Specified penalty level on sparsity of the factor matrix. The default is NULL. \n#' @param kfold: The fold number for cross-validation.\n#' @param Chunk: Whether to use EM-in-chunks algorithm. The default is TRUE.\n#' @param chunk.size: The chunk size (number of genes) for EM-in-chunks algorithm. The default is 1000.        \nFactorAnalysisWithSpikein <- function(Expression, Spikein, k1, k2, iter = 500, alpha = 10, \n                            kappa = 2, diagH = 1, g = 1, h1 = 1, h2 = 1, c = 1, d = 1, limit = 25,\n                            method = c(\"EM\", \"EMSparse\", \"EMSparseTraining\", \"EMSparseNfold\", \"IBP\", \"PCA\"), \n                            penalty = seq(0.01, 10, length.out = 20), tol = 0.1, givenpenalty = NULL, kfold = NULL,\n                            Chunk = TRUE, chunk.size = 1000) {\n  method <- match.arg(method)\n  X <- Expression \n  Y <- Spikein\n  \n  n <- nrow(X)\n  q <- ncol(X)\n  p <- ncol(Y)\n  \n  if (method == \"EM\") {\n    if(Chunk == TRUE & q > chunk.size){\n      chunk <- ceiling(q/chunk.size)\n      res <- PLSfactorEMchunk(X, Y, k1, k2, iter, chunk)\n    } else {\n      res <- PLSfactorEM(X, Y, k1, k2, iter)\n    }\n    lambda <- res$lambda\n    lambdaU <- lambda[(k1+1):(k1+k2), (p+1):(p+q)]\n    lambdaX <- lambda[1:k1, (p+1):(p+q)]\n    lambdaY <- lambda[1:k1, 1:p]\n    Z <- as.matrix(res$Z[, 1:k1])\n    Q <- as.matrix(res$Z[, (k1+1):(k1+k2)])\n    denoised <- Q%*%lambdaU\n    \n  } else if (method == \"EMSparseTraining\"){\n    \n    res <- PLSfactorEMpenaltyTrain(Y, X, k1, k2, iter, penalty, tol)\n    lambdaU <- res$lambdaU\n    lambdaX <- res$lambdaX\n    lambdaY <- res$lambdaY\n    Z <- as.matrix(res$Z[, 1:k1])\n    Q <- as.matrix(res$Z[, (k1+1):(k1+k2)])\n    denoised <- Q%*%lambdaU\n    \n  } else if (method == \"EMSparse\"){\n    \n    if(is.null(givenpenalty)) stop(\"Method \\\"EMSparse\\\" requires the specification of penalty for sparisty.\")\n    res <- PLSfactorEMpenaltyGivenPen(Y, X, k1, k2, iter, givenpenalty, tol)\n    lambdaU <- res$lambdaU\n    lambdaX <- res$lambdaX\n    lambdaY <- res$lambdaY\n    Z <- as.matrix(res$Z[, 1:k1])\n    Q <- as.matrix(res$Z[, (k1+1):(k1+k2)])\n    denoised <- Q%*%lambdaU\n    \n  } else if (method == \"EMSparseNfold\"){\n   \n    if(is.null(kfold)) stop(\"Method \\\"EMSparseNfold\\\" requires the specification of k-fold cross validation.\")\n    res <- PLSfactorEMpenaltyNfoldCV(Y, X, k1, k2, iter, kfold, penalty, tol)\n    lambdaU <- res$lambdaU\n    lambdaX <- res$lambdaX\n    lambdaY <- res$lambdaY\n    Z <- as.matrix(res$Z[, 1:k1])\n    Q <- as.matrix(res$Z[, (k1+1):(k1+k2)])\n    denoised <- Q%*%lambdaU\n    \n  } else if (method == \"IBP\") {\n    \n    sigma <- sd(X)/2\n    res <- PLSIBPfactormodel(Y, X, k1, k2, iter, sigma = sigma, alpha = alpha, kappa = kappa, diagH = diagH, \n                             g = g, h1 = h1, h2 = h2, c = c, d = d, limit = limit)\n    lambdaU <- res$lambdaU\n    lambdaX <- res$lambdaX\n    lambdaY <- res$lambdaY\n    Z <- as.matrix(as.matrix(res$Z))\n    Q <- as.matrix(as.matrix(res$Q))\n    denoised <- Q%*%lambdaU\n    \n  } else if (method == \"PCA\") {\n    \n    res <- NaivePCA(X, Y, k1, k2)\n    lambda <- res$lambda\n    lambdaU <- lambda[(k1+1):(k1+k2), (p+1):(p+q)]\n    lambdaX <- lambda[1:k1, (p+1):(p+q)]\n    lambdaY <- lambda[1:k1, 1:p]\n    Z <- as.matrix(res$Z[, 1:k1])\n    Q <- as.matrix(res$Z[, (k1+1):(k1+k2)])\n    denoised <- Q%*%lambdaU\n    \n  }\n  \n  if(method != \"PCA\"){    \n    E_x <- X - denoised - Z%*%lambdaX\n    psi_x <- res$psi[-(1:p)]\n    psi_x[psi_x < 0.000001] <- 0.000001 \n    Ex_Likelihood <- 0\n    for(j in 1:q){\n      #if(is.na(sum(dnorm(c(E_x[, j]), 0, psi_x[j], TRUE)))) print(j)\n      Ex_Likelihood <- Ex_Likelihood + sum(dnorm(c(E_x[, j]), 0, psi_x[j], TRUE))\n    }\n    report <- list(lambdaU, Q, denoised, Ex_Likelihood, Z, lambdaX, lambdaY, psi_x)\n    names(report) <- c(\"Factor\", \"Loading\", \"Denoised\", \"Ex_Likelihood\", \"Z\", \"lambdaX\", \"lambdaY\", \"psi_x\")\n    \n  } else {\n    \n    report <- list(lambdaU, Q, denoised, Z, lambdaX, lambdaY)\n    names(report) <- c(\"Factor\", \"Loading\", \"Denoised\", \"Z\", \"lambdaX\", \"lambdaY\")\n    \n  }\n  return(report)\n}",
    "created" : 1452571798493.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1167127628",
    "id" : "5C4CC154",
    "lastKnownWriteTime" : 1452572853,
    "path" : "~/Google Drive/Software/Citrus-master/R/FactorAnalysisWithSpikein.R",
    "project_path" : "R/FactorAnalysisWithSpikein.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}