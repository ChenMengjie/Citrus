{
    "contents" : "PLSMixtureFactorModelSpikein <- function(Expression, Spikein, k1, k2, iniL = 3, TruncateL = 20, \n                        iter = 1000, maxK = 20, nu0 = 50, r = 0.1, s = 200, alpha = 1, alpha2 = 5,\n                        kappa0 = 1, m = 0.75, g = 1, c = 1, d = 1, kappa = 2, diagH = 1, h1 = 1, h2 = 1, s1 = 1, s2 = 1, \n                        iter_to_average = 10, method = c(\"SpikeSlab\", \"IBP\"), mergeCluster = TRUE, mergeN = 5, average_label = TRUE){\n  \n  method <- match.arg(method)\n  X <- Expression \n  Y <- Spikein\n  sigma <- sd(X)/2\n  mu0 <- rep(0, k2)\n  Sigma0 <- diag(k2)\n  n <- nrow(X)\n  if(nrow(Y) != n) stop(\"Spike-in and gene expression matrix should have the same number of samples (rows).\")\n  \n  q <- ncol(X)\n  p <- ncol(Y)\n  \n  if (method == \"SpikeSlab\") {\n    res <- DirichletSpikePLSModel(Y = Y, X = X, k1 = k1, K = k2, iniL = iniL, TruncateL = TruncateL, \n                                  iter = iter, nu0 = nu0, sigma = sigma, r = r, s = s, alpha = alpha,\n                                  mu0 = mu0, Sigma0 = Sigma0, kappa0 = kappa0, m = m, g = g, \n                                  c = c, d = d, diagH = diagH, h1 = h1, h2 = h2, s1 = s1, s2 = s2, iter_to_average = iter_to_average)\n  } else if (method == \"IBP\") {\n    res <- DirichletIBPPLSModel(Y = Y, X = X, k1 = k1, K = k2, iniL = iniL, TruncateL = TruncateL, \n                                iter = iter, maxK = maxK, nu0 = nu0, sigma = sigma, r = r, s = s, alpha = alpha, \n                                alpha2 = alpha2, mu0 = mu0, Sigma0 = Sigma0, kappa0 = kappa0, m = m, g = g, \n                                c = c, d = d, kappa = kappa, diagH = diagH, h1 = h1, h2 = h2, s1 = s1, s2 = s2, iter_to_average = iter_to_average)\n  }\n  \n  Q <- res$Q\n  \n  if(average_label == TRUE){\n    ClusterAssign <- apply(res$AveC, 2, which.max)\n    ClusterList <- unique(ClusterAssign)\n  } else {\n    ClusterAssign <- res$C + 1\n    ClusterList <- unique(ClusterAssign) \n  }\n  \n  if (method == \"IBP\"){\n    activeK <- ncol(Q)\n    MuList <- res$Mu[ClusterList, 1:activeK]\n    SigmaList <- res$Sigma[1:activeK, 1:activeK, ClusterList]  \n  } else if (method == \"SpikeSlab\") {\n    MuList <- res$Mu[ClusterList, ]\n    SigmaList <- res$Sigma[, , ClusterList]\n  }\n  \n  ClusterLabel <- NULL\n  for(i in 1:n){\n    ClusterLabel <- c(ClusterLabel, which(ClusterList == ClusterAssign[i]))\n  }\n  \n  BeforeMergeClusterLabel <- ClusterLabel\n    \n  l <- length(ClusterList)  \n  \n  if(mergeCluster == TRUE){ \n    mergelist <- which(table(ClusterLabel) <= mergeN)\n    if(length(mergelist) > 0){\n      currentLabel <- ClusterLabel\n      currentMu <- MuList[-mergelist, ]\n      currentCluster <- c(1:l)[-mergelist]\n      for(j in 1:length(mergelist)){  \n        distance <- apply(currentMu, 1, function(x){\n          sum((x - MuList[mergelist[j], ])^2) \n        })  \n        currentLabel[currentLabel == mergelist[j]] <- currentCluster[which.min(distance)]\n      }\n      ClusterLabel <- NULL\n      for(i in 1:n){\n        ClusterLabel <- c(ClusterLabel, which(currentCluster == currentLabel[i]))\n      }\n      MuList <- currentMu\n      SigmaList <- SigmaList[, , -mergelist]\n    }    \n  }\n  \n  lambda <- res$lambdaU\n  denoised <- Q%*%lambda\n  \n  E_x <- X - denoised - res$Z%*%res$lambdaX\n  E_y <- Y - res$Z%*%res$lambdaY \n  \n  psi_y <- res$psi[1:p]\n  psi_x <- res$psi[-(1:p)]\n  \n  Likelihood <- 0\n  for(i in 1:n){\n    Likelihood <- Likelihood + dmvnrmRowArma(Q[i, ], MuList[ClusterLabel[i], ], SigmaList[, , ClusterLabel[i]], TRUE) \n  }\n  for(j in 1:p){\n    Likelihood <- Likelihood + sum(dnorm(c(E_y[, j]), 0, psi_y[j], TRUE))\n  }\n  for(j in 1:q){\n    Likelihood <- Likelihood + sum(dnorm(c(E_x[, j]), 0, psi_x[j], TRUE))\n  }\n  Likelihood <- Likelihood + sum(dnorm(c(lambda), 0, res$sigma, TRUE))\n  \n  Ex_Likelihood <- 0\n  for(j in 1:q){\n    Ex_Likelihood <- Ex_Likelihood + sum(dnorm(c(E_x[, j]), 0, psi_x[j], TRUE))\n  }\n  \n  adjustRes <- .identifiablityAdjust(res$Q, res$lambdaU)\n  Q <- adjustRes[[1]]\n  Lambda <- adjustRes[[2]]\n  report <- list(Lambda, Q, ClusterLabel, denoised, Likelihood, MuList, Ex_Likelihood, BeforeMergeClusterLabel)\n  names(report) <- c(\"SparseFactor\", \"Loading\", \"Cluster\", \"Denoised\", \"Likelihood\", \"Mu\", \"Ex_Likelihood\", \"ClusterBeforeMerging\")\n  class(report) <- \"CitrusReport\"\n  return(report)\n}\n",
    "created" : 1452571783487.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3881615895",
    "id" : "E8F60A91",
    "lastKnownWriteTime" : 1446410769,
    "path" : "~/Google Drive/Software/Citrus-master/R/PLSMixtureFactorModelSpikein.R",
    "project_path" : "R/PLSMixtureFactorModelSpikein.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}